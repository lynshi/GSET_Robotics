/*
Room 409
Maze Code
*/

#define MAX 60
#define RATIO 2
#define FIRSTUS 18
#define TURNDIST 25

#define SINGLE_TURN_ANGLE_TO_ENCODER 4.8
#define DOUBLE_TURN_ANGLE_TO_ENCODER 2.4

int black, white, lightAvg;
int dir = -1; //if dir == 1, back; dir == -1, fwd
int ball = 0; //ball found = 1, no ball yet = 0
int inMaze = 0; //0 if not in the maze, 1 if in the maze

task lineFollow();
task color();
task mazeNav();
void mazeTurn();
int turnCheck();
int ballFind();
task ballCatch();

void turnHeadTo(int degrees);

void singleWheelTurn(byte motor, int degrees);
void doubleWheelTurn(int degrees);
//void pointTurn(byte motors, int degrees);

void driveUpToWall(int look=0);
void driveUpToNotWall(int look2=0);

void switchDir();
void displayNum(int n);
void calibration();

task main(){
     //calibration(); //calibrates black and white for line following
     //Precedes(lineFollow); //color too
     //OnFwdSync(OUT_AC,dir*30,0);
     //Wait(1500);
     SetSensorUltrasonic(S2);
     Precedes(mazeNav);
}

task lineFollow(){ //follows line to get into maze
     while(turnCheck()){ //change to color sensor
          if(SENSOR_1 > lightAvg){
               OnFwd(OUT_C,dir*MAX - dir*MAX*RATIO*(SENSOR_1 - lightAvg)/(white - lightAvg));
               OnFwd(OUT_A,dir*MAX);
          }
          else if(SENSOR_1 <= lightAvg){
               OnFwd(OUT_A,dir*MAX - dir*MAX*RATIO*(SENSOR_1 - lightAvg)/(black - lightAvg));
               OnFwd(OUT_C,dir*MAX);
          }
     }

     OnFwd(OUT_AC,0);
     Precedes(mazeNav); //ballFind too
}

task color(){

}

task mazeNav(){ //used to navigate the maze
     driveUpToWall();
     singleWheelTurn(OUT_A,90); //left
     driveUpToWall(); //enter room 1
     doubleWheelTurn(90); //right
     if(ballFind()){
         ballCatch();
         doubleWheelTurn(90);
         driveUpToNotWall(-90);
         singleWheelTurn(OUT_C, 90); // right
         // exit
         Wait(100000);
     }
     doubleWheelTurn(90); //right, get out of Room 1
     driveUpToWall(); //enter Room 3
     doubleWheelTurn(-90); //left
     if(ballFind()){
          //go get the damn ball
          ballCatch();
          doubleWheelTurn(-90);
          driveUpToNotWall(90);
          singleWheelTurn(OUT_A, 90);  // left
          // exit
          Wait(999999);
     }
     doubleWheelTurn(-90); //left
     driveUpToWall(-90); //gets out of Room 3 and finds center wall
     driveUpToNotWall(-90); //finds Room 3
     singleWheelTurn(OUT_C,90); //right
     OnFwdSync(OUT_AC,30,0);
     Wait(1500);
     
     if(ballFind()){
      //get the ********* ball
          ballCatch();
          OnFwdSync(OUT_AC,100,0); // High tail it out of there
          Wait(1000);
          
     }
     driveUpToWall(); //go into Room 2
     doubleWheelTurn(90); //right
     if(ballFind()){
      //get the ball already
     }
     
     doubleWheelTurn(90); //right
     if(ballFind()){
      //where the hell is it
     }
     
     //Precedes(ballCatch);
}

void turnHeadTo(int degrees)
{
    long delta = degrees - MotorRotationCount(OUT_B);
    RotateMotor(OUT_B, 60, delta);
}

void driveUpToNotWall(int look2=0){
     turnHeadTo(look2);
     OnFwdSync(OUT_AC, dir*MAX, 0);
     while(!turnCheck());
     OnFwdSync(OUT_AC, 0, 0);
}

void driveUpToWall(int look=0)
{
     turnHeadTo(look);
     OnFwdSync(OUT_AC, dir*MAX, 0);
     while(turnCheck());
     OnFwdSync(OUT_AC, 0, 0);
}

void doubleWheelTurn(int degrees){
     RotateMotorEx(OUT_AC, MAX, dir*degrees*DOUBLE_TURN_ANGLE_TO_ENCODER, 100, true, true);
     Wait(100);
}

void singleWheelTurn(byte motor, int degrees)
{
     RotateMotor(motor, MAX, dir*degrees*SINGLE_TURN_ANGLE_TO_ENCODER);
     Wait(100);
}

void mazeTurn(){
     OnFwdSync(OUT_AC,0,0);
     
     for(int i = 0; i < 2; i++){
          RotateMotor(OUT_B,30,-90 - 180*i);
          Wait(1000);
          if(turnCheck()){ //checks to make sure if turn is okay
               RotateMotor(OUT_B,30,90 + 180*i);
               Wait(1000);
               if(i == 0){ //turn right
                    RotateMotor(OUT_C,30,dir*360);
               }
               else if(i == 1){ //turn left
                    RotateMotor(OUT_A,30,dir*360);
               }
               return;
          }
     }
     
     switchDir();
}

int turnCheck(){ //if no need to turn return 1; otherwise return 0
    if(SensorUS(S2) > TURNDIST){
         return 1;
    }
    else{
         return 0;
    }
}

int ballFind(){ //detects the ball in a room
     return 0;
}

void ballCatch(){ //moves to the ball in a room and captures it
     //find the ball
}

void switchDir(){ //flips the ultrasonic sensor to enable driving in reverse
     if(dir == -1){
          dir = 1;
          RotateMotor(OUT_B,30,-180);

     }
     else if(dir == 1){
          dir = -1;
          RotateMotor(OUT_B,30,180);
     }
}

void displayNum(int n){ //displays a number
     ClearScreen();
     TextOut(0,2,NumToStr(n));
     Wait(1500);
     ClearScreen();
}

void calibration(){ //calibrates light sensor and starts the robot
     SetSensorLight(S1,1);
     TextOut(0,2,"Set black");
     Wait(3000);
     black = SENSOR_1;
     displayNum(black);
     TextOut(0,2,"Set white");
     Wait(3000);
     white = SENSOR_1;
     displayNum(white);

     lightAvg = (black + white) / 2;
     displayNum(lightAvg);

     TextOut(0,2,"3"); //Here we go
     Wait(1000);
     ClearScreen();
     TextOut(0,2,"2");
     Wait(1000);
     ClearScreen();
     TextOut(0,2,"1");
     Wait(1000);
     ClearScreen();
     TextOut(0,2,"GO!");
     Wait(1000);
     ClearScreen();
}
